#+TITLE:     R quick reference card
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+Time-stamp: <2013-10-23 Wed 12:14>
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  american

#+PROPERTY:  eval no
#+PROPERTY:  exports both
#+SETUPFILE: ~/src/org-style/bigblow-local-abs.setup

* R reference card

Welcome to R reference card. It contains the reference documentation that
describes how to perform *data analysis* using R.

* 0. Overview of R

R system that you download from [[http://cran.r-project.org/][CRAN]]:
- =base= package
- Familiar packages (=utils=, =datasets=, ...)
- Recommended packages (=lattice=, ...)
- 4,000 other packages

[[http://cran.r-project.org/doc/contrib/Short-refcard.pdf][R Reference Card]]

Some [[http://cran.r-project.org/manuals.html][R manuals]]:
- [[http://cran.r-project.org/doc/manuals/R-intro.html][An introduction to R]]
- [[http://cran.r-project.org/doc/manuals/r-release/R-data.html][R data import/export]]
- [[http://cran.r-project.org/doc/manuals/R-exts.html][Writing R extensions]]

* 1. Getting started and getting help

#+begin_src R
?function
?dataset
package ? lattice
library(help = lattice)
#+end_src

- =args(function)= ::
     Look at the arguments of a FUNCTION.

- Google
- [[mailto:r-help@r-project.org][R general mailing list]]
- [[http://stackoverflow.com/questions/tagged/r][Stack Overflow]]

* 2. Some basics

** Print something

- =print(object)= ::
     Explicitly print out an object.

- =cat()= ::
     Concatenate together a set of strings and prints out the concatanated
     string (to a file or to the console).

** Setting variables

- =<-= ::
     Assign a value to a variable.

** Listing variables

- =ls()=, =ls.str()= ::
     Show objects in my workspace.

** Deleting variables

- =rm()= ::
     Remove objects from your workspace.

     #+begin_src R
     rm(list=ls())                      # remove everything from the workspace
     #+end_src

** Computing basic statistics

- =mean()= ::
     Take the mean.

- =median()= ::
     Take the median.

- =cor()= ::
     Correlation function.

** Creating sequences

- =n:m= ::
     Create an *sequence of* integers from =n= to =m= (=n= < =m= or =n= > =m=).

- =seq(from, to, len)= ::
     Create a *sequence of* =len= equally spaced fractional numbers.

- =rep(x, times)= ::
     Create a series of repeated values.

** Operators

- =%in%= ::
     Test membership.

** Defining a function

#+begin_src R
myfunction <- function(x) {
    y <- norm(100)
    mean(y)
}
#+end_src

* 3. Navigating the software

- =getwd()= ::
     Figure out what your working directory is.

- =library(package)= ::
     Load PACKAGE.

     #+begin_src R
     library(datasets)
     airquality
     #+end_src

- =data(dataset)= ::
     Load DATASET.

- =source("file.R")= ::
     Evaluate R code file.

** Running a batch script

You may write a script containing R code:

#+begin_src sh
#!/usr/bin/env Rscript

argv <- commandArgs(TRUE)
x <- as.numeric(argv[1])
# etc.
#+end_src

* 5. Data structures

| Class     | Example                     |
|-----------+-----------------------------|
| =logical=   | =TRUE= / =FALSE=                |
| =integer=   | =1L= (with explicit =L= suffix) |
| =numeric=   | =0.5= or =1= (/real/ numbers)     |
| =complex=   | =1+0i=                        |
| =character= | "hello" (lowest class)      |

- =class()= ::
     Show the class of the object.

- =unclass(vector)= ::
     Strip out the class (see factors).

** Vectors

*Vectors* are sets of elements of the /same class/.

When objects of different classes are mixed in a vector, /coercion/ occurs behind
the scene so that every element is of the same class (the "lowest common
denominator" class).

- =c()= ::
     Create a vector of objects (that is, *concatenate* or combine things
     together).

- =vector(class, length)= ::
     Create an empty vector.

- =names()= ::
     Show or give a name to each *element* of a vector.

- =length()= ::

** Matrices

*Matrices* are vectors with *2 dimensions* (see =dimension= attribute).

They are constructed /column-wise/ (vector inserted by column).

They can be created from vectors by adding a dimension attribute:

#+begin_src R :eval yes
v <- 1:10
dim(v) <- c(2,5)
print(v)
#+end_src

#+results:
| 1 | 3 | 5 | 7 |  9 |
| 2 | 4 | 6 | 8 | 10 |

They can be created by /column-binding/ or /row-binding/.

- =matrix(nrow = x, ncol = y)= ::
     Create an empty matrix.

- =cbind()= ::
     Column-bind.

- =rbind()= ::
     Row-bind.

** Arrays

Arrays are *n-dimensional* matrices.

- =array()= ::
     Create an array.

** Lists

*Lists* are vectors of objects of possibly different classes.

The indexes of the elements of a list have double brackets around them.

- =list()= ::
     Construct a list.

** Factors

*Factors* are /qualitative/ variables used to represent /categorical/ data, to store
self-describing codes for /labels/ (such as "male" and "female", or "low",
"medium" and "high").

Unordered or ordered.

- =factor(character vector)= ::
     Create a factor variable (with levels by alphabetical order).

- =levels(x)= ::
     Return the value of the levels.

** Data frames

*Data frames* are used to store tabular data where each column can be of a
different class: special type of list (of columns) where every element has the
same length.

- Row = observation, column = variable
- Special attribute =row.names= (every row has a name, or defaults to a
  sequence of integers)
- Most often created by calling =read.table()= or =read.csv()=

- =data.frame()= ::
     Create a data frame.

- =data.matrix()= ::
     Convert a data frame to a /numeric/ matrix (forced *coercion*!).

- =names()= ::
     Tell the names of each *column* included in the data frame.

** Vectorized operations (recycling rule)

Avoid writing loops (code is a lot simpler):

#+begin_src R
x + y                                   # element-wise addition
#+end_src

Similar for the matrices:

#+begin_src R
x * y                                   # element-wise multiplication
x %*% y                                 # true matrix multiplication
#+end_src

** Selecting list elements or data frame columns by position (subsetting)

- =[[= ::
     Extract a *single element* of a list (or a single column of a data frame).

     Can be used with /computed/ indices.

     Can extract nested elements of a list:

     #+begin_src R
     x[[1]][[3]]                        # same as: x[[c(1,3)]]
                                        # third element of the first element
     #+end_src

     Partial matching allowed at the command-line:

     #+begin_src R
     x[["a", exact = FALSE]]            # instead of: x[["aardvark"]]
     #+end_src

- =[= ::
     Return an object of the *same class* as the original: a list of elements (or
     a data frame built from multiple columns).

     Extract multiple elements of a list:

     #+begin_src R
     x[c(1,3)]
     #+end_src

     Remove the first column:

     #+begin_src R
     df[,-1]
     #+end_src

** Selecting list elements or data frame columns by name (subsetting)

- =$= ::
     Extract a single element of a list (or a single column of a data frame)
     *by name*: you don't have to remember where the element is in the list.

     #+begin_src R
     x$bar                              # same as x[["bar"]]
     #+end_src

     Can only be used with literal names.

     Partial matching allowed at the command-line:

     #+begin_src R
     x$a                                # instead of: x$aardvark
     #+end_src

** Selecting data frame columns by position (subsetting)

Matrices can be subsetted with =(row, col)= type indices.

Indices can also be missing:
- =x[i,]= :: Row i.
- =x[,j]= :: Column j.

By default,

- a single element is retrieved as a vector of length 1 rather than a 1x1
  matrix.

- a single column or a single row is retrieved as a vector, not as a matrix.

This can be turned off by setting =drop = FALSE= (don't drop the dimension).

* Control structures

Control structures mentioned here are primarily useful for writing programs.
For command-line interactive work, the =*apply= functions are more useful.

** Conditional statements

#+begin_src R
if (<condition>) {
    ## do something
} else {
    ## do something else
}
#+end_src

Here, the entire =if/else= construct is all about assigning a value to =y=:

#+begin_src R
y <- if(x > 3) {                        # x must be a scalar here, not a vector
    10
} else {
    0
}
#+end_src

** Loops

#+begin_src R
for (i in 1:10) {                       # successive values from a sequence or vector
    ## do something
}

for (letter in x) {                     # take elements from the vector
    ## do something
}
#+end_src

- seq_along(vector) ::
     Create an integer sequence that's equal to the *length of the input vector*.

- seq_len(integer) ::
     Create an integer sequence that's as long as the integer in input.

- nrow(dataset) ::
     Tell the number of rows.

- ncol(dataset) ::
     Tell the number of columns.

#+begin_src R
while (z >= 3 && z <= 10) {             # conditions are always evaluated from left to right
    ## do something
}
#+end_src

Initiate an infinite loop:

#+begin_src R
repeat {
    ## do something
    if(<condition>) {
        break                           # only way to exit a repeat loop
    }
}
#+end_src

- =break= ::
     Break the iteration of a loop.

- =next= ::
     Skip an iteration of a loop.

- =return= ::
     Exit an entire function and return a given value.

Better to use a =for= loop with an hard limit on the number of iterations that
it's allowed to run.

* Writing functions

- Functions are R objects of class =function=

#+begin_src R
f <- function(<arguments>) {
    ## do something
}
#+end_src

- Functions can be *passed as arguments to other functions*

- Functions can be nested, so that you can define a function inside of
  another function (implications: see *lexical scoping*)

- The return value of a function is the last expression in the function body
  to be evaluated

- 3 types of...
  + formal argument
  + local variable
  + free variable

** Arguments

- /Named arguments/ can potentially have /default values/ (useful: not every
  function call makes use of all the formal arguments; some can be /missing/)

- The /formal arguments/ are the arguments included in the function definition

- =formals()= returns a list of all the formal arguments of a function

- Arguments can be matched *positionally* or *by name*

  + When an argument is matched by name, it is "taken out" of the argument
    list and the remaining unnamed arguments are matched in the order that
    they are listed in the function definition

- Named arguments help when:

  + you want to use the defaults for evererything except for an argument near
    the end of the list

  + you can't remember the position of the argument

- Function arguments can also be partially /matched/
  1. Check for an exact match
  2. Check for a partial match
  3. Check for a positional match

- When defining a function, you can also set an argument value to =NULL= (there
  is nothing there)

- Arguments to functions are evaluated /lazily/ (only when needed to be
  evaluated

- The =...= argument indicates a variable number of arguments

  + Used when extending a function and you don't want to copy the entire
    argument list of the original function

  + Used by generic functions (such as =mean=) so that extra arguments can be
    passed to methods

  + Used when the number of arguments cannot be known in advance (see =paste=
    function)

  + Any argument that appears /after/ the =...= must be named explicitly and
    cannot be partially matched

** Scoping rules for R

- R searches through the /search list/ (a series of =environments=, an environment
  being a collection of symbol/value pairs) to bind the appropriate value to a
  symbol:

  + Search the global environment =.GlobalEnv= (always the first)

  + Search the namespaces of each of the packages on the search list

    #+begin_src R
    search()                            # find the search list
    #+end_src

  + Search the =base= package (always the last element)

- Last loaded package gets put in position 2 of the search list and
  everything else gets shifted

- Separate namespaces for functions and non-function objects

- R uses *lexical* (or /static/) *scoping* (instead of /dynamic scoping/): /the value
  of free variables are searched for in the environment in which the function/
  /was/ *defined* (until the empty environment, after the =base= package)

  + With *dynamic* scoping, the value of free variables is looked up in the
    environment from which the function was *called* (/calling environment/ =
    /parent frame/) -- see slide 24 of "Scoping Rules for R" for a comparative
    example

  + Other languages that support lexical scoping: Scheme, Perl, Python,
    Common Lisp

  + Consequences: all objects must be stored in memory, and all functions
    must carry a *pointer to their respective defining environment*

- Every environment has one parent environment (next thing down on the search
  list); it is possible for an environment to have mulitple "children"

- A function + an environment = a (/function/) /closure/

- In R (unlike C), you can have functions defined /inside other functions/ -- in
  this case, the environment in which a function is defined is the body of
  another function!

  #+begin_src R
  make.power <- function(n) {           # "constructor" function
      pow <- function(x) {
          x^n                           # n is a free variable (not defined
                                        # inside pow)
      }
      pow                               # return function as return value
  }
  #+end_src

  This function returns another function as its value

  #+begin_src R
  cube <- make.power(3)
  square <- make.power(2)
  #+end_src

- Functions:
  + environment(f) ::
  + parent.env(environment) :: next thing down on the search list
  + ls(environment) :: list all the variables in the environment
  + get(object, environment) :: get the value of an object inside an
       environment

* 4. Input and output

** Reading tabular data files

- =read.table("file.txt")= ::
     Read tabular data file, create data frame.

     Important arguments:
     + =file=,
     + =header=,
     + =sep= (defaults to the *space*)
     + =colClasses=, class of each column
     + =nrows=,
     + =comment.char=,
     + =skip=, number of lines to skip from the beginning
     + =stringsAsFactors= (defaults to =TRUE=)

** Reading from CSV files

- =read.csv("file.csv")= ::
     Read data from CSV file, create data frame.
     + =header= defaults to =TRUE=
     + default =separator=: *comma*

** Reading from SQL databases

#+begin_src R
library(RODBC)
## con <- odbcConnect("DSN", uid="username")
## con <- odbcDriverConnect("driver={SQL Server};server=hostname;database=dbname;trusted_connection=true")
con <- odbcDriverConnect("driver={SQL Server};server=hostname;database=dbname;uid=username;pwd=password")
sql <- "SELECT * FROM table"
rows <- sqlQuery(con, sql)
print(head(rows))
odbcClose(con)
#+end_src

* 6. Data transformations

(Partial list of) munging operations (= key process)
- *These steps must be recorded* in their own R script
- *90% of your effort will often be spent here*

** Removing list elements using a condition

*Subsetting* by using 2 types of index:
- a numeric vector (=x[2]=, =x[1:4]=)
- a *logical vector* (=x[x > "a"]=)

Create a logical vector:

#+begin_src R
u <- x > "a"
x[u]                                    # get all elements which are greater than "a"
#+end_src

Remove missing values (=NA=) from a list:

#+begin_src R
missing <- is.na(x)                     # logical vector
x[!missing]
#+end_src

Take the subset of all objects (=x= and =y=) that has no missing values:

#+begin_src R
bothnonmissing <- complete.cases(x, y)  # logical vector
x[bothnonmissing]
#+end_src

Take all the rows of a data frame where *all the values are not missing*:

#+begin_src R
nonmissing <- complete.cases(x)
x[nonmissing, ]
#+end_src

To *drop columns by name* in a data frame, you can use direct indexing (with
booleans vectors) and then, simply reassign data:

#+begin_src R
tokeep <- !names(x) %in% c("remove1", "remove2")
x <- x[,tokeep]                         # or...
x <- x[,tokeep, drop = FALSE]           # you will need this option to avoid
                                        # the conversion to an atomic vector if
                                        # there is only one column left
#+end_src

** Removing rows that contain NAs from a data frame

** Removing columns that contain NAs from a data frame

Get rid of any column that has one or more NAs.

#+begin_src R
df <- df[,colSums(is.na(df))==0]
#+end_src

** Merging data frames by commun column

Merge data sets.

#+begin_src R
mergedData <- merge(df1, df2, by.x="id1", by.y="id2", all=TRUE)
#+end_src

** Converting

- =as.*()= ::
     Explicitly coerce from one class to another.

- =as.numeric()= ::
     Coerce the (=character=) column to be =numeric=.

- =as.Date("January 2, 2007", "%B %d, %Y")= ::
     "2007-01-02"

- =as.ts()= ::
     Convert to a time series object.

Convert at once all the string columns to factors:

#+begin_src R
ind <- sapply(x, is.character)
x[ind] <- lapply(x[ind], factor)
#+end_src

** Applying a function to each list element

Alternative (to =for= *loops*) to apply a function (or summary statistics).

*** =lapply=

*Loop over a list* and apply a *function* on each element. /Always/ returns a *list*
back (that is, not a simplified result).

- (coerced) list =X=
- function =FUN=
- other arguments =...=

#+begin_src R
x <- list(a = 1:5, b = rnorm(10))
lapply(x, mean)
#+end_src

#+begin_src R
lapply(1:4, runif, min = 0, max = 10)   # arguments passed through the `...'
#+end_src

Extract the first column of each matrix of a list:

#+begin_src R
lapply(x, function(elt) elt[,1])
#+end_src

*** =sapply=

Same as =lapply=, but tries to "*simplify*" the result in a much more compact
format (put all the elements into a *vector* or a *matrix* if that is possible,
instead of returning a list).

#+begin_src R
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
#+end_src

Pass =na.rm= argument to =ColMeans= to remove the missing values before calculating
the mean.

#+begin_src R
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")], na.rm = TRUE))
#+end_src

** Splitting a vector into groups

- =split(dataframe, dataframe$column)= ::
     Take a vector, and *split* it into subpieces (the number of groups
     identified by the levels of a *factor* variable). Always return a *list* (of
     lists?) back.

     + =drop = TRUE= ::
          Don't keep the empty levels of the factor.

Auxiliary function, used in conjunction with functions like =lapply= or =sapply= to
apply a function to those individual groups.

#+begin_src R
lapply(split(x, f), mean)
#+end_src

Like =tapply=, but without applying the summary statistics.

Splitting a data frame (or other kinds of lists), and apply an /anonymous
function/:

#+begin_src R
s <- split(airquality, airquality$Month) # split according to month
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")])
#+end_src

** Applying a function to every row/column

- =apply= ::

- Apply a function over the *margins* of an array
  + Often used to apply a function to the rows or columns of a matrix
  + Very useful if you wanna take *summaries* of matrices or higher-dimensional
    arrays (such as array of matrices)

- apply(X, MARGIN, FUN, ...)
  + X array (= vector which has dimensions attached to it)
  + MARGIN is an integer vector which indicates which margins should be
    "retained"
  + FUN you want to apply to each of the margins
  + ... for other arguments you wanna passed to the function

#+begin_src R
x <- matrix(rnorm(200), 20, 10)
apply(x, 2, mean)
#+end_src

- margin 1 = apply FUN for each row (dimension 1); preserve all the rows,
  eliminate all columns, get a vector of the number of rows

- margin 2 = for each column (dimension 2); first dimension has been
  eliminated

- Shortcut functions (/much/ faster on large matrices):
  + rowSums = apply(x, 1, sum)
  + rowMeans = apply(x, 1, mean)
  + colSums = apply(x, 2, sum)
  + colMeans = apply(x, 2, mean)

#+begin_src R
x <- matrix(rnorm(200), 20, 10)
apply(x, 1, quantile, probs = c(0.25, 0.75)) # no default value for `probs'
#+end_src

** Applying a function to groups of data

- =tapply(X, INDEX, FUN)= ::

- Short for "*table apply*"

- Apply a *function* over *subsets* of a vector:
  + Splits up a vector into little groups (such as men and women, indicated by
    a *factor*),
  + Applies a function to those groups and
  + Brings the pieces back together

- Function may be anonymous

- =Simplify = FALSE= to get back a list

  #+begin_src R
  tapply(x, f, mean, simplify = FALSE)  # = lapply(split(x, f), mean)
  #+end_src

- =interaction(f1, f2)= ::
     Combines all the levels of the first factor with all the levels of the
     second factor.

** Applying a function to parallel vectors or lists

- =mapply= ::

- mapply is a multivariate version of =lapply=: applies a function in parallel
  over a set of arguments

- Apply a *function* to the elements of *multiple lists* in parallel

  + For example, apply a function over 2 lists, where the elements of the
    first list go into one argument of the function, and the elements of the
    second list go into another argument of the function

- *Vectorizing a function* (that doesn't allow for vector arguments)

  #+begin_src R
  mapply(rnorm, 1:5, 1:5, 2) # fixed standard deviation
  #+end_src

  is the same as

  #+begin_src R
  list(rnorm(1, 1, 2),
       rnorm(2, 2, 2),
       rnorm(3, 3, 2),
       rnorm(4, 4, 2),
       rnorm(5, 5, 2))
  #+end_src

** Checking on and removing inconsistent values

* 7. Strings and dates

** Getting the length of a string

- =nchar()= ::
     Get the length of a string.

** Concatenating strings

- =paste()= ::
     *Concatenate* a set of *strings together* to create one string or a vector of
     strings.

** Regular expressions

For the moment, we assume pattern matching on *ASCII strings*...

Metacharacters:

- =^= ::
     Start of a line (or negation of a character class).

- =$= ::
     End of a line.

- =[]= ::
     Character classes.

- =.= ::
     Any character.

- =|= ::
     Or.

- =()= ::
     Subexpressions (alternatives or "remember" matched text).

- =?= ::
     Optional.

- \ ::
     "Escape" the metacharacter.

- =+= ::
     Any number, including none.

- =*= ::
     Any number, at least one -- it is "greedy" so it always matches the
     /longest/ possible string that satisfies the regular expression.

     The greediness can be turned off with the =?= metacharacter (make the regex
     "lazy"), as in:

     #+begin_src R
     ^s(.*?)s$
     #+end_src

- ={}= ::
     Interval quantifiers (minimum, maximum).

These functions can take vector arguments.

- =grep= ::
     Return the *indices* into the character vector where the regex pattern
     matches (it won't do anything).

     #+begin_src R
     i <- grep("regexp", vector) # get a set of indices
     j <- grep("anotherregexp", vector) # get another set of indices
     setdiff(i, j) # substract j elements from i when they are the same
     setdiff(j, i) # different result
     #+end_src

     Setting =value = TRUE= returns the *actual elements* of the character vector
     that match.

- =grepl= ::
     Return a *logical vector* (=TRUE= / =FALSE=) indicating which element matches
     (used for /subsetting/).

- =regexpr= ::
     Return the indices (integer vector) of the string *where the first match
     begins* and the length of the match.

     If I want to see what the match is, use =substr=:

     #+begin_src R
     regexpr("...", string)
     substr(string, start + length - 1)
     #+end_src

     Useful in conjunction with =regmatches= which extracts the matches in the
     strings without having you to use =substr=.

     #+begin_src R
     r <- regexpr("...", string)
     regmatches(string, r)
     #+end_src

- =gregexpr= ::
     Return *all of the matches* ("global") in a given string.

- =sub= ::
     Replace *the first match* with another string (used to strip out stuff by
     replacing the match with nothing).

- =gsub= ::
     Replace *all of the matches* with another string.

- =regexec= ::
     Give the indices (list) for parenthesized sub-expressions.

     If I want to see what the submatch is:

     #+begin_src R
     r <- regexpr("... (.*) ...", string) # find all the date fields
     m <- regmatches(string, r) # parse out
     dates <- sapply(m, function (x) x[2]) # extract the 2nd element of each list object
     dates <- as.Date(dates, "%B %d, %Y") # convert to date
     hist(dates, "month", freq = TRUE) # aggregate the dates by month and give an histogram
     #+end_src

* 8. Probability

* 9. General statistics

** Summarizing your data

- =range()= ::
     Give the min and the max (vector of length 2) of the observations (vector
     of numbers).

- =summary()= ::
     Produce a summary of the object.

** Tabulating factors

- =table(vector)= ::
     *Count* the number of observations in each /level/ (see factors). Give a
     frequency of how many levels there are.

* 10. Graphics
  :PROPERTIES:
  :eval:     yes
  :END:

2 systems:

- =base= ::
     Graphics are constructed piecemeal by *different function calls*;
     you can add things one by one:
     - annotate (some of the points in) the plot,
     - put some points on the canvas,
     - draw a title,
     - add some axis labels,
     - add some colors,
     - add a legend.

- =lattice= ::
     Graphics are constructed via a single function call: all options have to
     be specified at once (advantage: that allows R to calculate the necessary
     spacings, margins and font sizes).

Behavior:

- Base graphics functions have a "side effect": they plot data directly to
  the graphics device.

- Lattice graphics functions return an object of the class =trellis= (object
  designed for plotting).

  When you call Lattice functions, even if you don't assign it to a "plot
  object", the result will be *auto-printed* (generate the plot *on the
  graphics device*), so it will look like Lattice functions have a "side
  effect"

You cannot use functions from the base plotting system in a Lattice plot.

** Base graphics

*** Make a plot

- =plot= ::
     Create a *scatter plot* (or another type of plot, depending on the class of
     the object being plotted).

- =hist= ::
     Make an *histogram* showing the distribution of the numeric vector =x=.

- =boxplot= ::
     Create a box plot of the =y= variable by the grouping variable =x= (usually a
     =factor=).

**** Create a scatter plot

- =plot(x)= ::
     Plot the (numeric) data against the index (=1:N=).

- =plot(x, y)= ::
     Create a scatter plot of =x= and =y=.

     #+begin_src R :results graphics :file images/base-scatterplot.png
     data(iris)
     plot(iris$Petal.Length, iris$Petal.Width,
          main="Petals: Length vs Width",
          xlab="Length",
          ylab="Width")
     #+end_src

     #+results:
     [[file:images/base-scatterplot.png]]

- =plot(x, y, type = "n")= ::
     Set up the plot window, but don't actually plot the data in there.

- =plot(dfrm)= ::
     Create multiple scatter plots if your data frame contains more than
     2 columns.

     #+begin_src R :results graphics :file images/base-multi-scatterplots.png
     data(iris)
     plot(iris[,1:4], main="Multiple scatter plots")
     #+end_src

     #+results:
     [[file:images/base-multi-scatterplots.png]]

**** =hist=

Generic function: you can call it on different types of data. When you call
=hist= on a =Date= object, it requires an interval ("day" / "week" / "month" /
"year") in order to break it up into sequences.

**** =boxplot=

*** Add to an existing plot

- =lines= ::
     Add lines (connect all the dots).

     #+begin_src R :eval no
     lines(x, y)                        # all lines
     #+end_src

- =abline= ::
     Add a straight line.

     Plot the *regression line* of a scatter plot.

     #+begin_src R :results graphics :file images/base-abline.png
     data(iris)
     attach(iris)
     plot(Petal.Length, Petal.Width)
     fit <- lm(Petal.Width ~ Petal.Length)
     abline(fit, lwd=3, col="blue")
     #+end_src

     #+results:
     [[file:images/base-abline.png]]

- =points= ::
     Add points (=col= for boundary color, =bg= for fill color, =pch= for plotting
     character).

     Plot points *in groups separately*.

     #+begin_src R :results graphics :file images/base-points-distinguished.png
     data(iris)
     attach(iris)
     plot(Petal.Length, Petal.Width, type="n")
     points(Petal.Length[Species == "setosa"], Petal.Width[Species == "setosa"], col = "red")
     points(Petal.Length[Species == "versicolor"], Petal.Width[Species == "versicolor"], col = "green", pch = 20)
     points(Petal.Length[Species == "virginica"], Petal.Width[Species == "virginica"], col = "blue", pch = 19)
     #+end_src

     #+results:
     [[file:images/base-points-distinguished.png]]

     #+begin_src R :results graphics :file images/base-points-distinguished-col.png
     data(iris)
     plot(iris$Petal.Length, iris$Petal.Width, col=as.integer(iris$Species))
     #+end_src

     #+results:
     [[file:images/base-points-distinguished-col.png]]

- =text= ::
     Add text labels.

     #+begin_src R :eval no
     text(-2, 2, "Label")
     #+end_src

- =title= ::
     Add a title (or axis labels, subtitle, ...).

     #+begin_src R :eval no
     title("plot")
     plot(x, y, xlab = "Weight", ylab = "Height", main = "Scatterplot")
     #+end_src

- =mtext= ::
     Add text to the margins.

- =axis= ::
     *Annotate the axis* (tick marks, labels).

- =legend= ::
     Add a legend.

     #+begin_src R :eval no
     legend("topleft", legend = "Data", pch = 1)
     #+end_src

*** Changing graphical parameters

- =par()= ::
     control *all the graphing parameters* that you can specify (/defaults/ for all
     plots in a session, which can be overridden as arguments to specific
     plotting functions).

     + =pch= ::
          Plotting character (default: open circle symbol).

     + =lty= ::
          Line type (default: =solid= line).

     + =lwd= ::
          Line width.

     + =col= ::
          Plotting color.

     + =las= ::
          Orientation of the axis labels on the plot (=las = 2= will set the tick
          labels to be perpendicular to the axis).

     + =bg= ::
          Background color (default: =transparent=).

     + =mar= ::
          Margin size (vector of 4 numbers, 1 per side).

          #+begin_src R :eval no
          par(mar = c(2,2,1,1))
          #+end_src

     + =oma= ::
          Outer margin size (relevant if you have more than one plot per
          canvas).

     + =mfrow= ::
          Number of *plots per row and per column* on the canvas (filled
          row-wise).

          #+begin_src R :eval no
          par(mfrow = c(2,1))           # 2 rows and 1 column
          plot(x, y)
          plot(x, z)
          #+end_src

     + =mfcol= ::
          Number of plots per row and per column on the canvas (filled
          column-wise).

     Look at the defaults:

     #+begin_src R :eval no
     par("lty")
     #+end_src

- =?Devices= ::
     List graphical devices.

     + =pdf= ::
          Vector format (very, very large for a graphic with *2 million points*
          on it: specify information for every single object on the plot).

     + =png= ::
          Bitmapped format (specify information for pixels), losless
          *compression*, but *does not resize well*.

     + =jpeg= ::
          Lossy compression.

     + =bitmap= ::
          If you're running R in a batch mode (you can't use the =png= and =jpeg=
          functions).

- Copy the plot to another device
  + =dev.copy2pdf= :: copy a plot to PDF

** Lattice graphics

** ggplot2

See post of Antoine Lizée in
http://stackoverflow.com/questions/5234117/how-to-drop-columns-by-name-in-a-data-frame
for an excellent performance reporting.

* 11. Linear regression and ANOVA

* 12. Useful tricks

** Peeking at your data

- =head()= ::
     Look at the first 6 rows.

- =tail()= ::
     Look at the last 6 rows.

- =str()= ::
     /Compactly/ display the internal *structure* (*classes*, etc.) of an object.

     Alternative to =summary()=.

     When applied to functions, show the *arguments*.

     #+begin_src R
     str(.Platform)                     # what is the operating system
     #+end_src

- =attributes()= ::
     Access (set or modify) the (list of) attributes of an object.
